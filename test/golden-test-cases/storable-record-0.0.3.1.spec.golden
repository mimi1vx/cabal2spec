#
# spec file for package storable-record
#
# Copyright (c) 2018 SUSE LINUX GmbH, Nuernberg, Germany.
#
# All modifications and additions to the file contributed by third parties
# remain the property of their copyright owners, unless otherwise agreed
# upon. The license for this file, and modifications and additions to the
# file, is the same license as for the pristine package itself (unless the
# license for the pristine package is not an Open Source License, in which
# case the license is the MIT License). An "Open Source License" is a
# license that conforms to the Open Source Definition (Version 1.9)
# published by the Open Source Initiative.

# Please submit bugfixes or comments via http://bugs.opensuse.org/
#

%global pkg_name storable-record

Name:           %{pkg_name}
Version:        0.0.3.1
Release:        0
Summary:        Elegant definition of Storable instances for records
Group:          Development/Libraries/Haskell

License:        BSD-3-Clause
Url:            https://hackage.haskell.org/package/%{name}
Source0:        https://hackage.haskell.org/package/%{name}-%{version}/%{name}-%{version}.tar.gz

BuildRequires:  ghc-Cabal-devel
BuildRequires:  ghc-rpm-macros
BuildRequires:  ghc-transformers-devel
BuildRequires:  ghc-utility-ht-devel

%description
With this package you can build a Storable instance of a record type from
Storable instances of its elements in an elegant way. It does not do any magic,
just a bit arithmetic to compute the right offsets, that would be otherwise
done manually or by a preprocessor like C2HS. I cannot promise that the
generated memory layout is compatible with that of a corresponding C struct.
However, the module generates the smallest layout that is possible with respect
to the alignment of the record elements. If you encounter, that a record does
not have a compatible layout, we should fix that. But also without C
compatibility this package is useful e.g. in connection with StorableVector.

We provide Storable instance support for several cases:

* If you wrap a type in a 'newtype', then you can lift its 'Storable' instance
to that 'newtype' with the module "Foreign.Storable.Newtype". This way you do
not need the 'GeneralizedNewtypeDeriving' feature of GHC.

* If you have a type that is an instance of 'Traversable', you can use that
feature for implementation of 'Storable' methods. The module
"Foreign.Storable.Traversable" allows manipulation of the portion of your type,
that is accessible by 'Traversable' methods. For instance with the type 'data T
a = Cons Int [a]' and an according 'Traversable' implementation, you can load
and store the elements of the contained list. This may be part of a 'Storable'
implementation of the whole type.

* If you have a record containing elements of various types, then you need
module "Foreign.Storable.Record".

Note however that the Storable instances defined with this package are quite
slow in (up to) GHC-6.12.1. I'm afraid this is due to incomplete inlining, but
we have still to investigate the problem.

For examples see packages 'storable-tuple' and 'sample-frame'.


%package -n ghc-%{name}
Summary:        Haskell %{name} library
Group:          System/Libraries

%description -n ghc-%{name}
This package provides the Haskell %{name} shared library.


%package -n ghc-%{name}-devel
Summary:        Haskell %{name} library development files
Group:          Development/Libraries/Haskell
Requires:       ghc-compiler = %{ghc_version}
Requires(post): ghc-compiler = %{ghc_version}
Requires(postun): ghc-compiler = %{ghc_version}
Requires:       ghc-%{name} = %{version}-%{release}

%description -n ghc-%{name}-devel
This package provides the Haskell %{name} library development files.


%prep
%setup -q

%build
%ghc_lib_build

%install
%ghc_lib_install

%post -n ghc-%{name}-devel
%ghc_pkg_recache

%postun -n ghc-%{name}-devel
%ghc_pkg_recache

%files
%doc LICENSE

%files -n ghc-%{name} -f ghc-%{name}.files
%defattr(-,root,root,-)
%doc LICENSE

%files -n ghc-%{name}-devel -f ghc-%{name}-devel.files
%defattr(-,root,root,-)

%changelog
