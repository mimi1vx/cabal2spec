#
# spec file for package directory-tree
#
# Copyright (c) 2018 SUSE LINUX GmbH, Nuernberg, Germany.
#
# All modifications and additions to the file contributed by third parties
# remain the property of their copyright owners, unless otherwise agreed
# upon. The license for this file, and modifications and additions to the
# file, is the same license as for the pristine package itself (unless the
# license for the pristine package is not an Open Source License, in which
# case the license is the MIT License). An "Open Source License" is a
# license that conforms to the Open Source Definition (Version 1.9)
# published by the Open Source Initiative.

# Please submit bugfixes or comments via http://bugs.opensuse.org/
#

%global pkg_name directory-tree

%bcond_with tests

Name:           %{pkg_name}
Version:        0.12.1
Release:        0
Summary:        A simple directory-like tree datatype, with useful IO functions
Group:          Development/Libraries/Haskell

License:        BSD-3-Clause
Url:            https://hackage.haskell.org/package/%{name}
Source0:        https://hackage.haskell.org/package/%{name}-%{version}/%{name}-%{version}.tar.gz

BuildRequires:  ghc-Cabal-devel
BuildRequires:  ghc-rpm-macros
BuildRequires:  ghc-directory-devel
BuildRequires:  ghc-filepath-devel
%if %{with tests}
BuildRequires:  ghc-process-devel
%endif

%description
A simple directory-like tree datatype, with useful IO functions and Foldable
and Traversable instance

Provides a simple data structure mirroring a directory tree on the filesystem,
as well as useful functions for reading and writing file and directory
structures in the IO monad.

Importing the library and optional (useful) Foldable and Traverable libraries:

> import System.Directory.Tree > import qualified Data.Foldable as F > import
qualified Data.Traversable as T

Write a hand-made directory tree of textfiles (strings) to the disk.
Simulates creating a new user Tux's home directory on a unix machine:

> writeDirectory$ "/home" :/ Dir "Tux" [File "README" "Welcome!"]

"read" a directory by opening all the files at a filepath with readFile,
returning an 'AnchoredDirTree String' (d2). Then check for any IO failures:

> do (base :/ d2) <- readDirectory "../parent_dir/dir2/" > let failed =
anyFailed d2 > if failed then ...

Use Foldable instance function to concat a directory 'dir' of text files into a
single file under the same directory:

> do (b :/ dt) <- readDirectory dir > let f = F.concat dt > return$ b :/ File
"ALL_TEXT" f

Open all the files in the current directory as lazy bytestrings, ignoring the
base path in Anchored wrapper:

> import qualified Data.ByteString.Lazy as B > do (_ :/ dTree) <-
readDirectoryWith B.readFile "./"

This version also offers an experimental function `readDirectoryWithL` that
does lazy directory IO, allowing you to treat the returned `DirTree` as if it
were a normal lazily-generated data structure.

For example, the following does only the amount of IO necessary to list the
file names of the children of the root directory, similar to "ls /":

> do d <- readDirectoryWithL readFile "/" > mapM_ (putStrLn . name) $ contents
$ free d

Any ideas or suggestions for improvements are most welcome :-)

/CHANGES/: from 0.11

- export 'System.Directory.Tree.transformDir' as requested

- add test suite to cabal file

- remove redundant 'removeNonexistent' (thanks to dmwit for patch) .


%package -n ghc-%{name}
Summary:        Haskell %{name} library
Group:          System/Libraries

%description -n ghc-%{name}
This package provides the Haskell %{name} shared library.


%package -n ghc-%{name}-devel
Summary:        Haskell %{name} library development files
Group:          Development/Libraries/Haskell
Requires:       ghc-compiler = %{ghc_version}
Requires(post): ghc-compiler = %{ghc_version}
Requires(postun): ghc-compiler = %{ghc_version}
Requires:       ghc-%{name} = %{version}-%{release}

%description -n ghc-%{name}-devel
This package provides the Haskell %{name} library development files.


%prep
%setup -q

%build
%ghc_lib_build

%install
%ghc_lib_install

%check
%cabal_test

%post -n ghc-%{name}-devel
%ghc_pkg_recache

%postun -n ghc-%{name}-devel
%ghc_pkg_recache

%files
%doc LICENSE
%doc EXAMPLES

%files -n ghc-%{name} -f ghc-%{name}.files
%defattr(-,root,root,-)
%doc LICENSE

%files -n ghc-%{name}-devel -f ghc-%{name}-devel.files
%defattr(-,root,root,-)
%doc EXAMPLES

%changelog
