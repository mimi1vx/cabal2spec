#
# spec file for package slave-thread
#
# Copyright (c) 2018 SUSE LINUX GmbH, Nuernberg, Germany.
#
# All modifications and additions to the file contributed by third parties
# remain the property of their copyright owners, unless otherwise agreed
# upon. The license for this file, and modifications and additions to the
# file, is the same license as for the pristine package itself (unless the
# license for the pristine package is not an Open Source License, in which
# case the license is the MIT License). An "Open Source License" is a
# license that conforms to the Open Source Definition (Version 1.9)
# published by the Open Source Initiative.

# Please submit bugfixes or comments via http://bugs.opensuse.org/
#

%global pkg_name slave-thread

%bcond_with tests

Name:           %{pkg_name}
Version:        1.0.2
Release:        0
Summary:        A principal solution to ghost threads and silent exceptions
Group:          Development/Libraries/Haskell

License:        MIT
Url:            https://hackage.haskell.org/package/%{name}
Source0:        https://hackage.haskell.org/package/%{name}-%{version}/%{name}-%{version}.tar.gz

BuildRequires:  ghc-Cabal-devel
BuildRequires:  ghc-rpm-macros
BuildRequires:  ghc-base-prelude-devel
BuildRequires:  ghc-list-t-devel
BuildRequires:  ghc-mmorph-devel
BuildRequires:  ghc-partial-handler-devel
BuildRequires:  ghc-stm-containers-devel
BuildRequires:  ghc-transformers-devel
%if %{with tests}
BuildRequires:  ghc-HTF-devel
BuildRequires:  ghc-QuickCheck-devel
BuildRequires:  ghc-SafeSemaphore-devel
BuildRequires:  ghc-quickcheck-instances-devel
%endif

%description
Vanilla thread management in Haskell is low level and it does not approach the
problems related to thread deaths. When it's used naively the following typical
problems arise:

* When a forked thread dies due to an uncaught exception, the exception does
not get raised in the main thread, which is why the program continues to run as
if nothing happened, i.e., with the presumption that the already dead thread is
running normally. Naturally this may very well bring your program to a chaotic
state.

* Another issue is that one thread dying does not affect any of the threads
forked from it. That's why your program may be accumulating ghost threads.

* Ever dealt with your program ignoring the <Ctrl-C> strikes?

This library solves all the issues above with a concept of a slave thread.
A slave thread has the following properties:

1. When it dies for whatever reason (exception or finishing normally) it kills
all the slave threads that were forked from it. This protects you from ghost
threads.

2. It waits for all slaves to die and execute their finalizers before executing
its own finalizer and getting released itself. This gives you hierarchical
releasing of resources.

3. When a slave thread dies with an uncaught exception it reraises it in the
master thread. This protects you from silent exceptions and lets you be sure of
getting informed if your program gets brought to an erroneous state.


%package -n ghc-%{name}
Summary:        Haskell %{name} library
Group:          System/Libraries

%description -n ghc-%{name}
This package provides the Haskell %{name} shared library.


%package -n ghc-%{name}-devel
Summary:        Haskell %{name} library development files
Group:          Development/Libraries/Haskell
Requires:       ghc-compiler = %{ghc_version}
Requires(post): ghc-compiler = %{ghc_version}
Requires(postun): ghc-compiler = %{ghc_version}
Requires:       ghc-%{name} = %{version}-%{release}

%description -n ghc-%{name}-devel
This package provides the Haskell %{name} library development files.


%prep
%setup -q

%build
%ghc_lib_build

%install
%ghc_lib_install

%check
%cabal_test

%post -n ghc-%{name}-devel
%ghc_pkg_recache

%postun -n ghc-%{name}-devel
%ghc_pkg_recache

%files
%doc LICENSE

%files -n ghc-%{name} -f ghc-%{name}.files
%defattr(-,root,root,-)
%doc LICENSE

%files -n ghc-%{name}-devel -f ghc-%{name}-devel.files
%defattr(-,root,root,-)

%changelog
