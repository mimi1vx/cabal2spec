#
# spec file for package set-monad
#
# Copyright (c) 2018 SUSE LINUX GmbH, Nuernberg, Germany.
#
# All modifications and additions to the file contributed by third parties
# remain the property of their copyright owners, unless otherwise agreed
# upon. The license for this file, and modifications and additions to the
# file, is the same license as for the pristine package itself (unless the
# license for the pristine package is not an Open Source License, in which
# case the license is the MIT License). An "Open Source License" is a
# license that conforms to the Open Source Definition (Version 1.9)
# published by the Open Source Initiative.

# Please submit bugfixes or comments via http://bugs.opensuse.org/
#

%global pkg_name set-monad

Name:           %{pkg_name}
Version:        0.2.0.0
Release:        0
Summary:        Set monad
Group:          Development/Libraries/Haskell

License:        BSD-3-Clause
Url:            https://hackage.haskell.org/package/%{name}
Source0:        https://hackage.haskell.org/package/%{name}-%{version}/%{name}-%{version}.tar.gz

BuildRequires:  ghc-Cabal-devel
BuildRequires:  ghc-rpm-macros
BuildRequires:  ghc-containers-devel
BuildRequires:  ghc-deepseq-devel

%description
The 'set-monad' library exports the 'Set' abstract data type and
set-manipulating functions. These functions behave exactly as their namesakes
from the 'Data.Set' module of the 'containers' library. In addition, the
'set-monad' library extends 'Data.Set' by providing 'Functor', 'Applicative',
'Alternative', 'Foldable', 'Monad', and 'MonadPlus' instances for sets.

In other words, you can use the 'set-monad' library as a drop-in replacement
for the 'Data.Set' module of the 'containers' library and, in addition, you
will also get the aforementioned instances which are not available in the
'containers' package.

It is not possible to directly implement instances for the aforementioned
standard Haskell type classes for the 'Set' data type from the 'containers'
library. This is because the key operations 'map' and 'union', are constrained
with 'Ord' as follows.

> map :: (Ord a, Ord b) => (a -> b) -> Set a -> Set b > union :: (Ord a) => Set
a -> Set a -> Set a

The 'set-monad' library provides the type class instances by wrapping the
constrained 'Set' type into a data type that has unconstrained constructors
corresponding to monadic combinators. The data type constructors that represent
monadic combinators are evaluated with a constrained run function.
This elevates the need to use the constraints in the instance definitions (this
is what prevents a direct definition). The wrapping and unwrapping happens
internally in the library and does not affect its interface.

For details, see the rather compact definitions of the 'run' function and type
class instances. The left identity and associativity monad laws play a crucial
role in the definition of the 'run' function. The rest of the code should be
self explanatory.

The technique is not new. This library was inspired by [1]. To my knowledge,
the original, systematic presentation of the idea to represent monadic
combinators as data is given in [2]. There is also a Haskell library that
provides a generic infrastructure for the aforementioned wrapping and
unwrapping [3].

The 'set-monad' library is particularly useful for writing set-oriented code
using the do and/or monad comprehension notations. For example, the following
definitions now type check.

> s1 :: Set (Int,Int) > s1 = do a <- fromList [1 .. 4] > b <- fromList [1 ..
4] > return (a,b)

> -- with -XMonadComprehensions > s2 :: Set (Int,Int) > s2 = [ (a,b) | (a,b) <-
s1, even a, even b ]

> s3 :: Set Int > s3 = fmap (+1) (fromList [1 .. 4])

As noted in [1], the implementation technique can be used for monadic libraries
and EDSLs with restricted types (compiled EDSLs often restrict the types that
they can handle). Haskell's standard monad type class can be used for
restricted monad instances. There is no need to resort to GHC extensions that
rebind the standard monadic combinators with the library or EDSL specific ones.

'['1']' CSDL Blog: The home of applied functional programming at KU.
Monad Reification in Haskell and the Sunroof Javascript compiler.
<http://www.ittc.ku.edu/csdlblog/?p=88>

'['2']' Chuan-kai Lin. 2006. Programming monads operationally with Unimo.
In Proceedings of the eleventh ACM SIGPLAN International Conference on
Functional Programming (ICFP '06). ACM.

'['3']' Heinrich Apfelmus. The operational package.
<http://hackage.haskell.org/package/operational>.


%package -n ghc-%{name}
Summary:        Haskell %{name} library
Group:          System/Libraries

%description -n ghc-%{name}
This package provides the Haskell %{name} shared library.


%package -n ghc-%{name}-devel
Summary:        Haskell %{name} library development files
Group:          Development/Libraries/Haskell
Requires:       ghc-compiler = %{ghc_version}
Requires(post): ghc-compiler = %{ghc_version}
Requires(postun): ghc-compiler = %{ghc_version}
Requires:       ghc-%{name} = %{version}-%{release}

%description -n ghc-%{name}-devel
This package provides the Haskell %{name} library development files.


%prep
%setup -q

%build
%ghc_lib_build

%install
%ghc_lib_install

%post -n ghc-%{name}-devel
%ghc_pkg_recache

%postun -n ghc-%{name}-devel
%ghc_pkg_recache

%files
%doc LICENSE

%files -n ghc-%{name} -f ghc-%{name}.files
%defattr(-,root,root,-)
%doc LICENSE

%files -n ghc-%{name}-devel -f ghc-%{name}-devel.files
%defattr(-,root,root,-)

%changelog
