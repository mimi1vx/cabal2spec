#
# spec file for package unagi-chan
#
# Copyright (c) 2018 SUSE LINUX GmbH, Nuernberg, Germany.
#
# All modifications and additions to the file contributed by third parties
# remain the property of their copyright owners, unless otherwise agreed
# upon. The license for this file, and modifications and additions to the
# file, is the same license as for the pristine package itself (unless the
# license for the pristine package is not an Open Source License, in which
# case the license is the MIT License). An "Open Source License" is a
# license that conforms to the Open Source Definition (Version 1.9)
# published by the Open Source Initiative.

# Please submit bugfixes or comments via http://bugs.opensuse.org/
#

%global pkg_name unagi-chan

%bcond_with tests

Name:           %{pkg_name}
Version:        0.4.1.0
Release:        0
Summary:        Fast concurrent queues with a Chan-like API, and more
Group:          Development/Libraries/Haskell

License:        BSD-3-Clause
Url:            https://hackage.haskell.org/package/%{name}
Source0:        https://hackage.haskell.org/package/%{name}-%{version}/%{name}-%{version}.tar.gz

BuildRequires:  ghc-Cabal-devel
BuildRequires:  ghc-rpm-macros
BuildRequires:  ghc-atomic-primops-devel
BuildRequires:  ghc-primitive-devel
%if %{with tests}
BuildRequires:  ghc-containers-devel
%endif

%description
This library provides implementations of concurrent FIFO queues (for both
general boxed and primitive unboxed values) that are fast, perform well under
contention, and offer a Chan-like interface. The library may be of limited
usefulness outside of x86 architectures where the fetch-and-add instruction is
not available.

We export several variations of our design; some support additional
functionality while others try for lower latency by removing features or making
them more restrictive (e.g. in the 'Unboxed' variants).

- 'Unagi': a general-purpose near drop-in replacement for 'Chan'.

- 'Unagi.Unboxed': like 'Unagi' but specialized for primitive types; this may
perform better if a queue grows very large.

- 'Unagi.Bounded': a bounded variant with blocking and non-blocking writes, and
other functionality where a notion of the queue's capacity is required.

- 'Unagi.NoBlocking': lowest latency implementations for when blocking reads
aren't required.

- 'Unagi.NoBlocking.Unboxed': like 'Unagi.NoBlocking' but for primitive types.

Some of these may be deprecated in the future if they are found to provide
little performance benefit, or no unique features; you should benchmark and
experiment with them for your use cases, and please submit pull requests for
additions to the benchmark suite that reflect what you find.

Here is an example benchmark measuring the time taken to concurrently write and
read 100,000 messages, with work divided amongst increasing number of readers
and writers, comparing against the top-performing queues in the standard
libraries. The inset graph shows a zoomed-in view on the implementations here.

<<http://i.imgur.com/J5rLUFn.png>> .


%package -n ghc-%{name}
Summary:        Haskell %{name} library
Group:          System/Libraries

%description -n ghc-%{name}
This package provides the Haskell %{name} shared library.


%package -n ghc-%{name}-devel
Summary:        Haskell %{name} library development files
Group:          Development/Libraries/Haskell
Requires:       ghc-compiler = %{ghc_version}
Requires(post): ghc-compiler = %{ghc_version}
Requires(postun): ghc-compiler = %{ghc_version}
Requires:       ghc-%{name} = %{version}-%{release}

%description -n ghc-%{name}-devel
This package provides the Haskell %{name} library development files.


%prep
%setup -q

%build
%ghc_lib_build

%install
%ghc_lib_install

%check
%cabal_test

%post -n ghc-%{name}-devel
%ghc_pkg_recache

%postun -n ghc-%{name}-devel
%ghc_pkg_recache

%files
%doc LICENSE
%doc CHANGELOG.markdown

%files -n ghc-%{name} -f ghc-%{name}.files
%defattr(-,root,root,-)
%doc LICENSE

%files -n ghc-%{name}-devel -f ghc-%{name}-devel.files
%defattr(-,root,root,-)
%doc CHANGELOG.markdown

%changelog
